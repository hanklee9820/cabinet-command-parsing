/*!
 * Cabinet Command Parser
 * Copyright (c) 2025
 * All rights reserved.
 * 智能医疗耗材柜指令解析器
 */
class ProtocolParser{parse(t){const a=t.replace(/\s+/g,"").match(/.{1,2}/g);if(!a||a.length<3)return{success:!1,message:"指令格式错误或长度不足"};const e=a.map((t=>parseInt(t,16))),s=e[0];if(243===s)return this.parseDoorCommand(e);if(e.length>=2){const t=e[1],a=e[2];if(5===t||6===t){if(2===a)return this.parseWeightCommand(e);if(46===a)return this.parseDiscriminationRateCommand(e)}else if(99===t||100===t){if(6===e[2])return this.parseClearCommand(e);if(46===e[2])return this.parseDiscriminationRateCommand(e)}return{success:!1,message:"未知的指令类型，功能码: 0x"+t.toString(16).padStart(2,"0")}}return{success:!1,message:"未知的指令类型，包头: 0x"+s.toString(16).padStart(2,"0")}}parseDoorCommand(t){const a=t[3]<<8|t[4];let e="";4369===a?e="开门操作":4368===a&&(e="查询锁状态");const s=t[1]<<8|t[2],r=9===s,i=this.calculateDoorLRC(t.slice(0,-1)),n=t[t.length-1];if(i!==n)return{success:!1,type:"门锁控制器",isResponse:r,command:{code:"0x"+a.toString(16).padStart(4,"0"),name:e||"未知命令"},message:`[${e||"未知命令"}] ${r?"返回数据":"发送指令"}解析失败 - LRC校验失败 (计算值: 0x${i.toString(16).padStart(2,"0")}, 接收值: 0x${n.toString(16).padStart(2,"0")})`,details:{address:"0x"+t[5].toString(16).padStart(2,"0")+` (${t[5]}号柜)`,lockNumber:"0x"+t[9].toString(16).padStart(2,"0")+` (${t[9]}号锁)`}};const o=t[5],d=t[6]<<8|t[7],S=t[8],c=t[9],p={header:"0x"+t[0].toString(16).padStart(2,"0"),length:"0x"+s.toString(16).padStart(4,"0")+` (${s} bytes)`,commandCode:"0x"+a.toString(16).padStart(4,"0")+` (${e})`,address:"0x"+o.toString(16).padStart(2,"0")+` (${o}号柜)`,returnCode:"0x"+d.toString(16).padStart(4,"0"),sequence:"0x"+S.toString(16).padStart(2,"0"),lockNumber:"0x"+c.toString(16).padStart(2,"0")+` (${c}号锁)`,lrc:"0x"+n.toString(16).padStart(2,"0")+" (LRC校验通过)"};if(r){const a=t[10];p.status="0x"+a.toString(16).padStart(2,"0")+` (${1===a?"已开启":"已关闭"})`}return{success:!0,type:"门锁控制器",isResponse:r,command:{code:"0x"+a.toString(16).padStart(4,"0"),name:e},details:p,rawBytes:t.map((t=>"0x"+t.toString(16).padStart(2,"0")))}}parseWeightCommand(t){const a=t[0],e=t[1];if(6===e){const a=9,e=[];for(let s=0;s<t.length;s+=a)s+a<=t.length&&e.push(t.slice(s,s+a));if(1===e.length){const t=e[0],a=this.calculateWeightLRC(t.slice(0,-1)),s=t[t.length-1];if(a!==s)return{success:!1,type:"重力传感器",isResponse:!0,command:{name:"读传感器重量"},message:`[读传感器重量] 返回数据解析失败 - LRC校验失败 (计算值: 0x${a.toString(16).padStart(2,"0")}, 接收值: 0x${s.toString(16).padStart(2,"0")})`,details:{address:"0x"+t[0].toString(16).padStart(2,"0")+` (${t[0]}号传感器)`,functionCode:"0x"+t[1].toString(16).padStart(2,"0")}};const r=t[3],i=t[4],n=t[5]<<16|t[6]<<8|t[7],o=!(128&i),d=15&i,S=this.getDivisionValue(d),c=n,p=c*S*(o?1:-1),g=this.parseStatusByte(r);return{success:!0,type:"重力传感器",isResponse:!0,command:{name:"读传感器重量"},details:{address:"0x"+t[0].toString(16).padStart(2,"0")+` (${t[0]}号传感器)`,weight:p.toFixed(3),lrcStatus:"校验通过",statusByte:"0x"+r.toString(16).padStart(2,"0"),x4Byte:"0x"+i.toString(16).padStart(2,"0"),x3x2x1:"0x"+n.toString(16).padStart(6,"0"),divisionCode:d,divisionValue:S,divisionCount:c,isPositive:o,status:g},rawBytes:t.map((t=>"0x"+t.toString(16).padStart(2,"0")))}}const s=e.map((t=>{const a=this.calculateWeightLRC(t.slice(0,-1)),e=t[t.length-1],s=t[0],r=t[3],i=t[4],n=t[5]<<16|t[6]<<8|t[7],o=!(128&i),d=15&i,S=this.getDivisionValue(d),c=n,p=c*S*(o?1:-1),g=this.parseStatusByte(r);return{address:s,addressText:"0x"+s.toString(16).padStart(2,"0")+` (${s}号传感器)`,weight:p.toFixed(3)+"克",lrcStatus:a===e?"校验通过":"校验失败",lrcDetails:{calculated:"0x"+a.toString(16).padStart(2,"0"),received:"0x"+e.toString(16).padStart(2,"0")},statusByte:"0x"+r.toString(16).padStart(2,"0"),x4Byte:"0x"+i.toString(16).padStart(2,"0"),x3x2x1:"0x"+n.toString(16).padStart(6,"0"),divisionCode:d,divisionValue:S,divisionCount:c,isPositive:o,status:g}})),r=s.filter((t=>"校验失败"===t.lrcStatus)),i=r.length>0;let n="";if(i){n=`[读传感器重量] ${r.map((t=>t.address+"号")).join("、")}传感器返回数据校验失败`}return{success:!0,type:"重力传感器",isResponse:!0,command:{name:"读传感器重量"},message:n,details:{multipleResults:!0,weights:s.map((t=>({...t,address:t.addressText}))),hasLRCError:i},rawBytes:t.map((t=>"0x"+t.toString(16).padStart(2,"0")))}}const s=t.slice(0,-1),r=this.calculateWeightLRC(s),i=t[t.length-1];return r!==i?{success:!1,type:"重力传感器",isResponse:!1,command:{name:"读传感器重量"},message:`[读传感器重量] 发送指令解析失败 - LRC校验失败 (计算值: 0x${r.toString(16).padStart(2,"0")}, 接收值: 0x${i.toString(16).padStart(2,"0")})`,details:{address:"0x"+a.toString(16).padStart(2,"0")+` (${0===a?"全部地址":a+"号传感器"})`,functionCode:"0x"+e.toString(16).padStart(2,"0")}}:{success:!0,type:"重力传感器",isResponse:!1,command:{name:"读传感器重量"},details:{address:"0x"+a.toString(16).padStart(2,"0")+` (${0===a?"全部地址":a+"号传感器"})`,functionCode:"0x"+e.toString(16).padStart(2,"0"),lrc:"0x"+i.toString(16).padStart(2,"0")+" (LRC校验通过)"},rawBytes:t.map((t=>"0x"+t.toString(16).padStart(2,"0")))}}getDivisionValue(t){return{0:1e3,1:100,2:10,3:1,4:2,5:5,6:200,7:500,8:50,9:.5}[t]||1}parseStatusByte(t){return{"标定允许":!!(128&t),"固定值1":!!(64&t),"固定值0":!!(32&t),"故障":!!(16&t),"量程溢出":!!(8&t),"开机零位异常":!!(4&t),"稳定":!!(2&t),"零位":!!(1&t)}}calculateDoorLRC(t){let a=0;for(let e=1;e<t.length;e++){a=255&(a^t[e])}return a}calculateWeightLRC(t){let a=0;for(let e=0;e<t.length;e++){a=a+t[e]&255}return a}parseClearCommand(t){const a=t[0],e=t[1],s=(t[2],100===e),r=t.slice(0,-1),i=this.calculateWeightLRC(r),n=t[t.length-1];if(i!==n)return{success:!1,type:"重力传感器",isResponse:s,command:{name:"去皮置零/校准"},message:`[去皮置零/校准] ${s?"返回数据":"发送指令"}解析失败 - LRC校验失败 (计算值: 0x${i.toString(16).padStart(2,"0")}, 接收值: 0x${n.toString(16).padStart(2,"0")})`,details:{address:"0x"+a.toString(16).padStart(2,"0")+` (${0===a?"全部地址":a+"号传感器"})`,functionCode:"0x"+e.toString(16).padStart(2,"0")}};let o={};if(s){o={success:5===t[3]}}return{success:!0,type:"重力传感器",isResponse:s,command:{name:"去皮置零/校准"},details:{address:"0x"+a.toString(16).padStart(2,"0")+` (${0===a?"全部地址":a+"号传感器"})`,functionCode:"0x"+e.toString(16).padStart(2,"0"),lrc:"0x"+n.toString(16).padStart(2,"0")+" (LRC校验通过)",...o},rawBytes:t.map((t=>"0x"+t.toString(16).padStart(2,"0")))}}parseDiscriminationRateCommand(t){const a=t[0],e=t[1],s=(t[2],6===e||100===e),r=5===e||6===e,i=r?"读取鉴别率":"设置鉴别率",n=t.slice(0,-1),o=this.calculateWeightLRC(n),d=t[t.length-1];if(o!==d)return{success:!1,type:"重力传感器",isResponse:s,command:{name:i},message:`[${i}] ${s?"返回数据":"发送指令"}解析失败 - LRC校验失败 (计算值: 0x${o.toString(16).padStart(2,"0")}, 接收值: 0x${d.toString(16).padStart(2,"0")})`,details:{address:"0x"+a.toString(16).padStart(2,"0")+` (${0===a?"全部地址":a+"号传感器"})`,functionCode:"0x"+e.toString(16).padStart(2,"0")}};let S={},c="";if(r){if(s){const e=t[3];S={success:!0,discriminationRate:e},c=`0x${a.toString(16).padStart(2,"0")} (${a}号传感器) 当前鉴别率: ${e}`}}else if(s){const e=5===t[3];S={success:e},c=`0x${a.toString(16).padStart(2,"0")} (${a}号传感器) ${e?"设置成功":"设置失败"}`}else{const e=t[3];S={rate:e,rateDesc:0===e?"停止补偿跟踪":`${e}倍分度值`},c=`0x${a.toString(16).padStart(2,"0")} (${a}号传感器) 设置鉴别率: ${0===e?"停止补偿跟踪":e+"倍分度值"}`}return{success:!0,type:"重力传感器",isResponse:s,command:{name:i},details:{address:"0x"+a.toString(16).padStart(2,"0")+` (${0===a?"全部地址":a+"号传感器"})`,functionCode:"0x"+e.toString(16).padStart(2,"0"),lrc:"0x"+d.toString(16).padStart(2,"0")+" (LRC校验通过)",...S,statusDesc:c},rawBytes:t.map((t=>"0x"+t.toString(16).padStart(2,"0")))}}}window.ProtocolParser=new ProtocolParser;